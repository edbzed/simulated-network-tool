import { Node, Port } from '../../types/network';

interface Vulnerability {
  id: string;
  severity: 'low' | 'medium' | 'high' | 'critical';
  description: string;
  service?: string;
  port?: number;
}

export class VulnerabilityScanner {
  private static readonly KNOWN_VULNERABILITIES: Record<string, Vulnerability[]> = {
    ssh: [
      {
        id: 'CVE-2021-28041',
        severity: 'medium',
        description: 'OpenSSH through 8.4 has an observable timing difference in authentication.',
        service: 'ssh'
      }
    ],
    http: [
      {
        id: 'CVE-2021-44228',
        severity: 'critical',
        description: 'Log4j remote code execution vulnerability',
        service: 'http'
      }
    ],
    // Add more vulnerability definitions
  };

  async scanNode(node: Node): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];
    
    // Scan each open port
    for (const port of node.ports.filter(p => p.state === 'open')) {
      // Simulate scan delay
      await new Promise(resolve => setTimeout(resolve, 100 + Math.random() * 200));
      
      // Check for known vulnerabilities
      const serviceVulns = VulnerabilityScanner.KNOWN_VULNERABILITIES[port.service];
      if (serviceVulns) {
        // Randomly determine if vulnerability exists based on version
        serviceVulns.forEach(vuln => {
          if (this.isVulnerable(port, vuln)) {
            vulnerabilities.push({
              ...vuln,
              port: port.number
            });
          }
        });
      }
    }

    return vulnerabilities;
  }

  private isVulnerable(port: Port, vuln: Vulnerability): boolean {
    if (!port.version) return Math.random() < 0.1; // 10% chance if version unknown
    
    // Version-based vulnerability check (simplified)
    const versionNum = this.extractVersionNumber(port.version);
    return Math.random() < 0.2 && versionNum < 8.5; // Example threshold
  }

  private extractVersionNumber(version: string): number {
    const match = version.match(/\d+(\.\d+)?/);
    return match ? parseFloat(match[0]) : 0;
  }
}